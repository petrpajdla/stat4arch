{
  "hash": "bd11a756a4a3d6247106b7cac6b0d214",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Distance and similarity\"\nformat:\n  html: default\n  revealjs:\n    fontsize: 24px\n    output-file: slides_dist.html\n    footer: \"[AES_707](https://petrpajdla.github.io/stat4arch/) *Statistics seminar for archaeologists* | [Disctances](./dist.html)\"\n    chalkboard:\n      theme: whiteboard\n      chalk-effect: 0.0\n  pdf: default\nexecute:\n  echo: true\n  warning: false\n  cache: true\n---\n\n\n\n\n## Distance and similarity\n\n- Distance and similarity are more or less opposite concepts.\n- Distance is a **numerical measure** describing how are two objects (defined by certain variables) different (*pairwise distance*). \n- Different distance measures exist for different data types.\n \n:::: {.columns}\n::: {.column width=50% .fragment}\n### Distance\n\n- Scale 0 -- $\\infty$\n- 0 -- Two objects with 0 distance between them. \n- $\\infty$ -- Two objects with infinite distance. \n- In practice, maximum distance is often 1.\n- Denoted by $D$ (for distance, or dissimilarity).\n- $D = 1 - S$\n:::\n::: {.column width=50% .fragment}\n### Similarity \n\n- Scale 0 -- 1\n- 0 -- Two objects completely dissimilar (0%).\n- 1 -- Two objects competely similar (100%).\n- Denoted by $S$ (for similarity).\n- $S = 1 - D$\n:::\n::::\n\n\n## Different distance measures \n\n::: {.incremental}\n- Dichotomous variables\n  - Symmetrical -- Simple matching distance \n  - Asymmetrical -- Jaccard index (binary distance)\n- Categorical variables \n  - Hamming distance \n- Numeric continuous variables\n  - Euclidean distance \n  - Mahalanobis distance \n- Mixed data sets \n  - Gower's distance \n:::\n\n\n## Binary distances \n\n- For `TRUE`/`FALSE`, `1`/`0`, `presence`/`absence` (etc.) data\n\n:::: {.columns}\n::: {.column width=50% .fragment}\n### Symmetrical\n\n- Two **presences** as **match**.\n- Two **absences** as **match**.\n\nIf a trait is present, two objects are more similar.\nIf a trait is absent, two objects are more similar.\nFor example if *biological sex* is encoded in one variable with `0` for *male* and `1` for *female*, it is symmetrical.\n\n- **Simple maching distance**\n:::\n::: {.column width=50% .fragment}\n### Asymmetrical\n\n- Two **presences** as **match**.\n- Two **absences** as **mismatch**.\n\nIf a trait is present, two objects are more similar. \nIf a trait is **absent** in both cases, e.g. **undetermined**, **missing** etc., this does not affect similarity.\nThis is more practical in archaeology.\n\n- **Jaccard index**, i.e. **binary distance**\n\n`dist(x, method = \"binary\")`\n:::\n::::\n\n\n## Distance between (continuous) numeric data \n\n- To **remove effects of scale** (different units etc.), variables should be scaled (normalized).\n\n:::: {.columns}\n::: {.column width=50%}\n### Normalization\n\n- *z-score* or *z-transformation*\n:::\n::: {.column width=50%}\n$$\nz = \\frac{x - \\mu}{\\sigma}\n$$\n:::\n::::\n\n![](figs/z-score.png)\n\n\n## Euclidean distance \n\n:::: {.columns}\n::: {.column width=50%}\n- Defined for a **Cartesian coordinate space**.\n- Uses **Pythagorean theorem**.\n:::\n::: {.column width=50%}\n$$ \nd(p, q) = \\sqrt{(q_1 - p_1)^2 + (q_2 - p_2)^2} \n$$\n:::\n::::\n\n### In R...\n\nNormalization:  \n`scale(x, center = TRUE, scale = TRUE)`  \n\nEuclidean distance:  \n`dist(x, method = \"euclidean\")`\n<!-- - or using package [philentropy](https://drostlab.github.io/philentropy/index.html) `distance(x, method = \"euclidean\")` -->\n\n## Code along\n\n::: {.fragment}\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(dplyr)\ndarts <- read.csv(\"https://petrpajdla.github.io/stat4arch/lect/w09/data/dartpoints_numeric.csv\")\n```\n:::\n\n\n\n:::\n::: {.fragment}\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# summary of values\nsummary(select(darts, Length, Width, Thickness, Weight))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     Length           Width         Thickness          Weight      \n Min.   : 30.60   Min.   :14.50   Min.   : 4.000   Min.   : 2.300  \n 1st Qu.: 40.85   1st Qu.:18.55   1st Qu.: 6.250   1st Qu.: 4.550  \n Median : 47.10   Median :21.10   Median : 7.200   Median : 6.800  \n Mean   : 49.33   Mean   :22.08   Mean   : 7.271   Mean   : 7.643  \n 3rd Qu.: 55.80   3rd Qu.:25.15   3rd Qu.: 8.250   3rd Qu.:10.050  \n Max.   :109.50   Max.   :49.30   Max.   :10.700   Max.   :28.800  \n```\n\n\n:::\n:::\n\n\n\n:::\n::: {.fragment}\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# normalization\ndarts_norm <- darts %>%\n  mutate(Length = scale(Length), Width = scale(Width),\n         Thickness = scale(Thickness), Weight = scale(Weight))\n         \n# or this shorthand can be used\ndarts_norm <- darts %>%\n  mutate(across(all_of(c(\"Length\", \"Width\", \"Thickness\", \"Weight\")), scale))\n```\n:::\n\n\n\n:::\n::: {.fragment}\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# summary of normalized values\nsummary(select(darts_norm, Length, Width, Thickness, Weight))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n      Length.V1           Width.V1           Thickness.V1    \n Min.   :-1.470673   Min.   :-1.469440   Min.   :-2.1363403  \n 1st Qu.:-0.665879   1st Qu.:-0.683998   1st Qu.:-0.6670233  \n Median :-0.175152   Median :-0.189461   Median :-0.0466450  \n Mean   : 0.000000   Mean   : 0.000000   Mean   : 0.0000000  \n 3rd Qu.: 0.507941   3rd Qu.: 0.595981   3rd Qu.: 0.6390363  \n Max.   : 4.724271   Max.   : 5.279540   Max.   : 2.2389592  \n      Weight.V1     \n Min.   :-1.269966  \n 1st Qu.:-0.735154  \n Median :-0.200342  \n Mean   : 0.000000  \n 3rd Qu.: 0.572164  \n Max.   : 5.028928  \n```\n\n\n:::\n:::\n\n\n\n:::\n\n## Code along\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# subset of Travis and Darl types of dart points\ndarts_subset <- filter(darts_norm, Name %in% c(\"Travis\", \"Darl\")) \n\n# matrix with numerical variables only\ndarts_mx <- darts_subset %>% \n  select(Length, Width, Thickness, Weight) %>% \n  as.matrix()\n  \n# add row names to the matrix\nrownames(darts_mx) <- darts_subset$Name\n\n# count Euclidean distance \ndarts_d <- dist(darts_mx, method = \"euclidean\", diag = TRUE)\n\nround(as.matrix(darts_d)[1:6, 1:6], 2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     Darl Darl Darl Darl Darl Darl\nDarl 0.00 0.42 0.47 0.40 1.57 1.14\nDarl 0.42 0.00 0.43 0.43 1.50 1.18\nDarl 0.47 0.43 0.00 0.28 1.51 1.36\nDarl 0.40 0.43 0.28 0.00 1.74 1.47\nDarl 1.57 1.50 1.51 1.74 0.00 0.90\nDarl 1.14 1.18 1.36 1.47 0.90 0.00\n```\n\n\n:::\n:::\n\n\n\n\n- Result is a **distance matrix**.\n- It is **symmetrical**. **Lower triangular** is the same as **upper triangular**.\n- On the **diagonal**, there is distance of the given object to itself, i.e. 0.\n\n\n## Visualizing distance matrix\n\n- Package `corrplot` has a nice way of plotting heatmaps.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(corrplot)\n\n# arg. is.corr set to FALSE, because we are not visualizing correlation matrix\ncorrplot(as.matrix(darts_d), is.corr = FALSE)\n```\n\n::: {.cell-output-display}\n![](dist_files/figure-pdf/unnamed-chunk-6-1.pdf){fig-pos='H'}\n:::\n:::\n\n\n\n\n## Resources\n\nFor a much more detailed overview of distance methods, see the tutorial on classification by Schmidt, S. C. et al. [DOI: 10.5281/zenodo.6325372](https://doi.org/10.5281/zenodo.6325372)\n(direct link to a HTML file is [here](https://gitlab.com/oliver.nakoinz/klassifikator/-/blob/master/5tutorials/tutorial_complete_ENG.Rmd)).\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": null,
    "postProcess": false
  }
}